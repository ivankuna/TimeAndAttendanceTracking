package hr.betaSoft.utils;

import hr.betaSoft.model.*;
import hr.betaSoft.tools.DateTimeStorage;

import java.sql.Date;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class AttendanceDataHandler {

    public static List<AttendanceData> getFormattedAttendanceData(
            Employee employee,
            List<Attendance> paramAttendanceList,
            List<Attendance> paramAttendanceListForOvertimeCalc,
            List<Holiday> paramHolidayList,
            List<AbsenceRecord> absenceRecordList,
            String year, String month) {

        List<AttendanceData> resultList = new ArrayList<>();
        List<AttendanceData> attendanceDataListForOvertimeCalc;

        for (Attendance attendance : paramAttendanceList) {
            if (attendance.getStatus() != 0) {
                return  resultList;
            }
        }

        resultList = prepareAttendanceDataWithDateTimeAttributesPopulated(paramAttendanceList, year, month);

        attendanceDataListForOvertimeCalc = prepareAttendanceDataWithDateTimeAttributesPopulated(
                paramAttendanceListForOvertimeCalc, year, DateUtils.getMonthBefore(month));

        if (attendanceDataListForOvertimeCalc.isEmpty() || (Objects.equals(attendanceDataListForOvertimeCalc.get(attendanceDataListForOvertimeCalc.size() - 1).getDay(), DateUtils.WEEKDAYS.get(6)) &&
                Objects.equals(attendanceDataListForOvertimeCalc.get(attendanceDataListForOvertimeCalc.size() - 1).getDate(), DateUtils.reduceDateToDay(
                        DateUtils.getLastDateOfMonth(year, DateUtils.getMonthBefore(month)))))) {
            resultList = populateMiscTypeWorkHourAttributes(resultList, null, paramHolidayList, year, month, employee);
        } else {
            resultList = populateMiscTypeWorkHourAttributes(resultList, attendanceDataListForOvertimeCalc, paramHolidayList, year, month, employee);
        }

        resultList = populateAbsenceHoursAttributes(employee, resultList, absenceRecordList, paramHolidayList, year, month);

        resultList = displayTotalHoursOfWork(resultList);

        return resultList;
    }

    // Used for creating a list of AttendanceData objects that represent each day of the parameter month
    // with the following clock in/out date/time attributes populated:
    //  - int date
    //  - String day
    //  - String startOfWork
    //  - String endOfWork
    //  - String totalHoursOfWork
    private static List<AttendanceData> prepareAttendanceDataWithDateTimeAttributesPopulated(
            List<Attendance> paramAttendanceList,
            String year, String month) {

        List<AttendanceData> attendanceDataList = new ArrayList<>();
        List<AttendanceData> tempAttendanceDataList = new ArrayList<>();
        List<AttendanceData> resultList = new ArrayList<>();
        List<Integer> daysAccountedFor = new ArrayList<>();

        for (Attendance attendance : paramAttendanceList) {
            Date clockInDate;
            String clockInTime;
            Date clockOutDate;
            String clockOutTime;

            boolean autogenerated = false;

            // The following two If statements check for Attendance date values that are before or after the current month,
            // if true the clock in/out date/time values are hardcoded essentially "cutting off excess data"
            if (!Objects.equals(DateUtils.reduceDateToMonth(attendance.getClockInDate()), month)) {
                clockInDate = DateUtils.getFirstDateOfMonth(year, month);
                clockInTime = "00:00";
                autogenerated = true;
            } else {
                clockInDate = attendance.getClockInDate();
                clockInTime = attendance.getClockInTime();
            }

            if (!Objects.equals(DateUtils.reduceDateToMonth(attendance.getClockOutDate()), month)) {
                clockOutDate = DateUtils.getLastDateOfMonth(year, month);
                clockOutTime = "24:00";
            } else {
                clockOutDate = attendance.getClockOutDate();
                clockOutTime = attendance.getClockOutTime();
            }

            int reducedClockInDate = DateUtils.reduceDateToDay(clockInDate);
            int reducedClockOutDate = DateUtils.reduceDateToDay(clockOutDate);
            String tempDay = DateUtils.getDayOfDate(clockInDate);

            // Used for converting Attendance objects to AttendanceData objects
            if (clockOutDate.after(clockInDate)) {
                attendanceDataList.add(new AttendanceData(reducedClockInDate, DateUtils.getDayOfDate(clockInDate), clockInTime,
                    "24:00", DateUtils.returnTimeDifference(clockInDate.toString(), clockInTime, clockInDate.toString(), "24:00"), false));
                daysAccountedFor.add(reducedClockInDate);
                if (reducedClockOutDate - reducedClockInDate > 1) {
                    for (int i = 1; i < (reducedClockOutDate - reducedClockInDate); i++) {
                        tempDay = DateUtils.getDayAfter(tempDay);
                        attendanceDataList.add(new AttendanceData(reducedClockInDate + i, tempDay, "00:00","24:00", "24:00", true));
                        daysAccountedFor.add(reducedClockInDate + i);
                    }
                }
                attendanceDataList.add(new AttendanceData(reducedClockOutDate, DateUtils.getDayOfDate(clockOutDate), "00:00",
                        clockOutTime, DateUtils.returnTimeDifference(clockOutDate.toString(), "00:00", clockOutDate.toString(), clockOutTime), true));
                daysAccountedFor.add(reducedClockOutDate);
            } else {
                attendanceDataList.add(new AttendanceData(reducedClockInDate, DateUtils.getDayOfDate(clockInDate), clockInTime, clockOutTime,
                        DateUtils.returnTimeDifference(clockInDate.toString(), clockInTime, clockOutDate.toString(), clockOutTime), autogenerated));
                daysAccountedFor.add(reducedClockInDate);
            }
        }

        int numOfDaysInMonth = DateUtils.getNumOfDaysInMonth(year, month);

        // Used for creating AttendanceData objects representing days without activity in terms of clocking in/out
        for (int i = 1; i <= numOfDaysInMonth; i++) {
            if (!daysAccountedFor.contains(i)) {
                tempAttendanceDataList.add(new AttendanceData(i, DateUtils.returnWeekday(i, month, year), "", "", "", false));
            }
        }
        // Used for populating the result list with AttendanceData objects representing each day of the parameter month
        for (int i = 1; i <= numOfDaysInMonth; i++) {
            for (AttendanceData attendanceData : attendanceDataList) {
                if (attendanceData.getDate() == i) {
                    resultList.add(attendanceData);
                }
            }
            for (AttendanceData attendanceData : tempAttendanceDataList) {
                if (attendanceData.getDate() == i) {
                    resultList.add(attendanceData);
                }
            }
        }

        return resultList;
    }

    // Used for taking an AttendanceData list provided by the method called "prepareAttendanceDataWithDateTimeAttributesPopulated"
    // and populating the following attributes of the objects contained in the list:
    //    - String nightWork;
    //    - String sundayWork;
    //    - String holidayWork;
    //    - String overtimeWork;
    private static List<AttendanceData> populateMiscTypeWorkHourAttributes(
            List<AttendanceData> attendanceDataList,
            List<AttendanceData> attendanceDataListForOvertimeCalc,
            List<Holiday> paramHolidayList,
            String year, String month,
            Employee employee) {

        // List used for keeping track of sundays in order to enable segmenting
        // of data into weeks during the calculation of weekly overtime work
        List<Integer> listOfSundayIndex = new ArrayList<>();

        for (AttendanceData attendanceData : attendanceDataList) {
            // 1) Setting the "nightWork" value
            attendanceData.setNightWork(returnTotalHoursOfNightWork(attendanceData, employee, year, month));
            // 2) Setting the "sundayWork" value
            if (attendanceData.getDay().equals(DateUtils.WEEKDAYS.get(6))) {
                if (!isHoliday(paramHolidayList, DateUtils.returnSqlDate(attendanceData.getDate(), month, year))) {
                    attendanceData.setSundayWork(Objects.equals(attendanceData.getTotalHoursOfWork(), "00:00") ? "" : attendanceData.getTotalHoursOfWork());
                }
                listOfSundayIndex.add(attendanceDataList.indexOf(attendanceData));
            }
            // 3) Setting the "holidayWork" value
            if (isHoliday(paramHolidayList, DateUtils.returnSqlDate(attendanceData.getDate(), month, year))) {
                attendanceData.setHolidayWork(attendanceData.getTotalHoursOfWork());
            }
            // Adds the final day of the month to the list of sundays for overtime calculation
            if (!listOfSundayIndex.contains(attendanceDataList.indexOf(attendanceData)) &&
                    attendanceDataList.indexOf(attendanceData) == (attendanceDataList.size() - 1)) {
                listOfSundayIndex.add(attendanceDataList.indexOf(attendanceData));
            }
        }

        // 4) Setting the "nightWork" value
        if (Objects.equals(employee.getOvertimeSchedule(), Employee.OVERTIME_SCHEDULE.get(0))) {
            for (Integer sundayIndex : listOfSundayIndex) {
                attendanceDataList = weeklyOvertimeCalc(employee, attendanceDataList, attendanceDataListForOvertimeCalc,
                        sundayIndex, listOfSundayIndex.indexOf(sundayIndex) == 0);
            }
        } else {
            attendanceDataList = dailyOvertimeCalc(employee, attendanceDataList, year, month);
        }

        return attendanceDataList;
    }

    private static List<AttendanceData> populateAbsenceHoursAttributes(
            Employee employee,
            List<AttendanceData> attendanceDataList,
            List<AbsenceRecord> absenceRecordList,
            List<Holiday> holidayList,
            String year, String month) {

        List<Integer> dayValueOfAbsenceDatesList = new ArrayList<>();
        List<String> typeOfAbsenceList = new ArrayList<>();
        List<Integer> tempRecurringDateIndexList = new ArrayList<>();
        List<Integer> recurringDateIndexList = new ArrayList<>();
        int counter = 0;
        String totalWorkHoursForRecurringDate = "00:00";

        for (AbsenceRecord absenceRecord : absenceRecordList) {
            if (!Objects.equals(DateUtils.reduceDateToMonth(absenceRecord.getStartDate()), month)) {
                absenceRecord.setStartDate(DateUtils.getFirstDateOfMonth(year, month));
            }
            if (!Objects.equals(DateUtils.reduceDateToMonth(absenceRecord.getEndDate()), month)) {
                absenceRecord.setEndDate(DateUtils.getLastDateOfMonth(year, month));
            }
        }

        for (int i = 1; i <= DateUtils.getNumOfDaysInMonth(year, month); i++) {
            for (AttendanceData attendanceData : attendanceDataList) {
                if (Objects.equals(attendanceData.getDate(), i)) {
                    tempRecurringDateIndexList.add(attendanceDataList.indexOf(attendanceData));
                    counter++;
                }
            }
            if (counter > 1) {
                recurringDateIndexList.addAll(tempRecurringDateIndexList);
                for (int j = tempRecurringDateIndexList.size() - 1; j >= 0; j--) {
                    totalWorkHoursForRecurringDate = DateUtils.timeAddition(totalWorkHoursForRecurringDate, attendanceDataList.get(tempRecurringDateIndexList.get(j)).getTotalHoursOfWork());
                }
                attendanceDataList.get(tempRecurringDateIndexList.get(tempRecurringDateIndexList.size() - 1)).setTotalHoursOfWorkForAbsenceCalc(totalWorkHoursForRecurringDate);
            }
            tempRecurringDateIndexList.clear();
            counter = 0;
            totalWorkHoursForRecurringDate = "00:00";
        }

        for (AbsenceRecord absenceRecord : absenceRecordList) {
            if (absenceRecord.getEndDate().after(absenceRecord.getStartDate())) {
                for (int i = DateUtils.reduceDateToDay(absenceRecord.getStartDate()); i <= DateUtils.reduceDateToDay(absenceRecord.getEndDate()); i++) {
                    dayValueOfAbsenceDatesList.add(i);
                    typeOfAbsenceList.add(absenceRecord.getTypeOfAbsence());
                }
            } else {
                dayValueOfAbsenceDatesList.add(DateUtils.reduceDateToDay(absenceRecord.getStartDate()));
                typeOfAbsenceList.add(absenceRecord.getTypeOfAbsence());
            }
        }

        for (AttendanceData attendanceData : attendanceDataList) {
            for (Integer date : dayValueOfAbsenceDatesList) {
                if (Objects.equals(attendanceData.getDate(), date)) {
                    if (!recurringDateIndexList.contains(attendanceDataList.indexOf(attendanceData))) {
                        attendanceData = setTypeOfAbsenceValueForAttendanceData(employee, attendanceData, typeOfAbsenceList.get(dayValueOfAbsenceDatesList.indexOf(date)), false);
                    } else {
                        attendanceData = setTypeOfAbsenceValueForAttendanceData(employee, attendanceData, typeOfAbsenceList.get(dayValueOfAbsenceDatesList.indexOf(date)), true);
                    }
                }
            }
        }

        Date tempDate;
        String tempOffDaysAndHolidays = "";

        for (AttendanceData attendanceData : attendanceDataList) {
            tempDate = DateUtils.returnSqlDate(attendanceData.getDate(), month, year);
            for (Holiday holiday : holidayList) {
                if (Objects.equals(tempDate, holiday.getDateOfHoliday())) {
                    if (!recurringDateIndexList.contains(attendanceDataList.indexOf(attendanceData)) ||
                            recurringDateIndexList.contains(attendanceDataList.indexOf(attendanceData)) && !Objects.equals(attendanceData.getTotalHoursOfWorkForAbsenceCalc(), null)) {
                        if (!Objects.equals(employee.getSignOutDate(), null)) {
                            if ((holiday.getDateOfHoliday().after(employee.getSignUpDate()) || holiday.getDateOfHoliday().equals(employee.getSignUpDate())) &&
                                    (holiday.getDateOfHoliday().before(employee.getSignOutDate()) || holiday.getDateOfHoliday().equals(employee.getSignOutDate()))) {
                                tempOffDaysAndHolidays = DateUtils.timeSubtraction(Employee.getWorkHoursForGivenDayStr(employee, attendanceData.getDay()),
                                        Objects.equals(attendanceData.getTotalHoursOfWorkForAbsenceCalc(), null) ? attendanceData.getTotalHoursOfWork() : attendanceData.getTotalHoursOfWorkForAbsenceCalc());
                                attendanceData.setOffDaysAndHolidays(checkForNegativeTime(tempOffDaysAndHolidays) ? "" : tempOffDaysAndHolidays);
                            }
                        } else {
                            if (holiday.getDateOfHoliday().after(employee.getSignUpDate()) || holiday.getDateOfHoliday().equals(employee.getSignUpDate())) {
                                tempOffDaysAndHolidays = DateUtils.timeSubtraction(Employee.getWorkHoursForGivenDayStr(employee, attendanceData.getDay()),
                                        Objects.equals(attendanceData.getTotalHoursOfWorkForAbsenceCalc(), null) ? attendanceData.getTotalHoursOfWork() : attendanceData.getTotalHoursOfWorkForAbsenceCalc());
                                attendanceData.setOffDaysAndHolidays(checkForNegativeTime(tempOffDaysAndHolidays) ? "" : tempOffDaysAndHolidays);
                            }
                        }
                    }
                }
            }
        }

        return attendanceDataList;
    }

    private static AttendanceData setTypeOfAbsenceValueForAttendanceData(
            Employee employee,
            AttendanceData attendanceData,
            String typeOfAbsence,
            boolean recurringDateData) {

        if (attendanceData.getTotalHoursOfWorkForAbsenceCalc() == null && recurringDateData) {
            return attendanceData;
        }

        String workHoursForGivenDay = Employee.getWorkHoursForGivenDayStr(employee, attendanceData.getDay());
        String totalHoursOfWork = recurringDateData ? attendanceData.getTotalHoursOfWorkForAbsenceCalc() : attendanceData.getTotalHoursOfWork();
        String hoursOfAbsence = DateUtils.timeSubtraction(workHoursForGivenDay, totalHoursOfWork);

        if (checkForNegativeTime(hoursOfAbsence) || Objects.equals(hoursOfAbsence, "00:00")) {
            hoursOfAbsence = "";
        }

        switch (typeOfAbsence) {
            case "Godišnji odmor":
                attendanceData.setAnnualLeave(hoursOfAbsence);
                break;
            case "Bolovanje":
                attendanceData.setSickLeave(hoursOfAbsence);
                break;
            case "Plaćeni dopust":
                attendanceData.setPaidLeave(hoursOfAbsence);
                break;
            case "Neplaćeni dopust":
                attendanceData.setUnpaidLeave(hoursOfAbsence);
                break;
            case "Opravdani izostanak":
                attendanceData.setExcusedAbsence(hoursOfAbsence);
                break;
            case "Neopravdani izostanak":
                attendanceData.setUnexcusedAbsence(hoursOfAbsence);
                break;
        }

        return attendanceData;
    }

    private static String returnTotalHoursOfNightWork(AttendanceData attendanceData, Employee employee, String year, String month) {

        String timeA = attendanceData.getStartOfWork();
        String timeB = attendanceData.getEndOfWork();
        String nightWork = "";
        String dateInQuestion = String.format(year + "-" + month + "-%02d", attendanceData.getDate());

        if (isNightWork(employee, timeA)) {
            if (isNightWork(employee, timeB)) {
                if (attendanceData.getStartOfWork().compareTo(employee.getNightWorkEnd()) <= 0 &&
                        attendanceData.getEndOfWork().compareTo(employee.getNightWorkStart()) >= 0) {
                    String nightWorkMorning = DateUtils.returnTimeDifference(dateInQuestion, attendanceData.getStartOfWork(), dateInQuestion, employee.getNightWorkEnd());
                    String nightWorkEvening = DateUtils.returnTimeDifference(dateInQuestion, employee.getNightWorkStart(), dateInQuestion, attendanceData.getEndOfWork());
                    nightWork = DateUtils.timeAddition(nightWorkMorning, nightWorkEvening);
                } else {
                    nightWork = DateUtils.returnTimeDifference(dateInQuestion, attendanceData.getStartOfWork(), dateInQuestion, attendanceData.getEndOfWork());
                }
            } else {
                nightWork = DateUtils.returnTimeDifference(dateInQuestion, attendanceData.getStartOfWork(), dateInQuestion, employee.getNightWorkEnd());
            }
        } else {
            if (isNightWork(employee, timeB)) {
                nightWork = DateUtils.returnTimeDifference(dateInQuestion, employee.getNightWorkStart(), dateInQuestion, attendanceData.getEndOfWork());
            }
        }

        return nightWork;
    }

    private static List<AttendanceData> weeklyOvertimeCalc(
            Employee employee,
            List<AttendanceData> attendanceDataList,
            List<AttendanceData> attendanceDataListForOvertimeCalc,
            Integer sundayIndex,
            boolean firstGo) {

        String weeklyWorkingHours = String.format("%02d:00", employee.getWeeklyWorkingHours());
        String actualTotalHoursOfWork = "00:00";
        String overtime = "00:00";
        boolean isOvertime = false;

        int startIndex = 0;
        int endIndex = sundayIndex;

        if (attendanceDataListForOvertimeCalc != null && firstGo) {
            int tempMonIndex = 0;
            for (AttendanceData attendanceDataOT : attendanceDataListForOvertimeCalc) {
                if (Objects.equals(attendanceDataOT.getDay(), DateUtils.WEEKDAYS.get(0))) {
                    tempMonIndex = attendanceDataListForOvertimeCalc.indexOf(attendanceDataOT);
                }
            }
            for (int i = tempMonIndex; i < attendanceDataListForOvertimeCalc.size(); i++) {
                String tempTime = attendanceDataListForOvertimeCalc.get(i).getTotalHoursOfWork();
                actualTotalHoursOfWork = DateUtils.timeAddition(actualTotalHoursOfWork, tempTime.trim().isEmpty() ? "00:00" : tempTime);
            }
            if (checkForNegativeTime(DateUtils.timeSubtraction(weeklyWorkingHours, actualTotalHoursOfWork))) {
                overtime = DateUtils.timeSubtraction(actualTotalHoursOfWork, weeklyWorkingHours);
            }
        }

        for (int i = sundayIndex; i >= 0; i--) {
            if (Objects.equals(attendanceDataList.get(i).getDay(), DateUtils.WEEKDAYS.get(0)) &&
                    !Objects.equals(attendanceDataList.get(Math.max(i - 1, 0)).getDay(), DateUtils.WEEKDAYS.get(0))) {
                startIndex = i;
                break;
            }
        }

        for (int i = startIndex; i <= endIndex; i++) {
            String tempTime = attendanceDataList.get(i).getTotalHoursOfWork().trim().isEmpty() ?
                    "00:00" : attendanceDataList.get(i).getTotalHoursOfWork();
            actualTotalHoursOfWork = DateUtils.timeAddition(actualTotalHoursOfWork, tempTime);
        }

        if (checkForNegativeTime(DateUtils.timeSubtraction(weeklyWorkingHours, actualTotalHoursOfWork))) {
            isOvertime = true;
            overtime = attendanceDataListForOvertimeCalc == null ? DateUtils.timeSubtraction(actualTotalHoursOfWork, weeklyWorkingHours) :
            DateUtils.timeAddition(overtime, DateUtils.timeSubtraction(actualTotalHoursOfWork, weeklyWorkingHours));
        }

        if (isOvertime) {
            for (int i = endIndex; i >= startIndex; i--) {
                String totalHoursOfWork = attendanceDataList.get(i).getTotalHoursOfWork().trim().isEmpty() ?
                        "00:00" : attendanceDataList.get(i).getTotalHoursOfWork();
                if (checkForNegativeTime(DateUtils.timeSubtraction(overtime, totalHoursOfWork))) {
                    attendanceDataList.get(i).setOvertimeWork(Objects.equals(overtime, "00:00") ? "" : overtime);
                    break;
                } else {
                    attendanceDataList.get(i).setOvertimeWork(Objects.equals(totalHoursOfWork, "00:00") ? "" : totalHoursOfWork);
                    overtime = DateUtils.timeSubtraction(overtime, totalHoursOfWork);
                }
            }
        }
        return attendanceDataList;
    }

    private static List<AttendanceData> dailyOvertimeCalc(Employee employee, List<AttendanceData> attendanceDataList, String year, String month) {

        List<Integer> recurringDateIndexList = new ArrayList<>();
        int numberOfDaysInMonth = DateUtils.getNumOfDaysInMonth(year, month);
        int counter = 0;
        int currentIndex;
        String blankTimeHolder = "00:00";
        String totalHoursOfWorkForRecurringDate = blankTimeHolder;
        String overtime = blankTimeHolder;
        String workHoursForGivenDayForRecurringDate = "";

        for (int i = 1; i <= numberOfDaysInMonth; i++) {
            for (AttendanceData attendanceData : attendanceDataList) {
                if (i == attendanceData.getDate()) {
                    recurringDateIndexList.add(attendanceDataList.indexOf(attendanceData));
                    counter++;
                }
            }
            if (counter > 1) {
                workHoursForGivenDayForRecurringDate = Employee.getWorkHoursForGivenDayStr(employee, attendanceDataList.get(recurringDateIndexList.get(0)).getDay());
                for (Integer index : recurringDateIndexList) {
                    totalHoursOfWorkForRecurringDate = DateUtils.timeAddition(attendanceDataList.get(index).getTotalHoursOfWork(), totalHoursOfWorkForRecurringDate);
                }
                if (checkForNegativeTime(DateUtils.timeSubtraction(workHoursForGivenDayForRecurringDate, totalHoursOfWorkForRecurringDate))) {
                    overtime = DateUtils.timeSubtraction(totalHoursOfWorkForRecurringDate, workHoursForGivenDayForRecurringDate);
                }
                if (!overtime.equals(blankTimeHolder)) {
                    for (int j = recurringDateIndexList.size() - 1; j >= 0; j--) {
                        currentIndex = recurringDateIndexList.get(j);
                        if (checkForNegativeTime(DateUtils.timeSubtraction(overtime, attendanceDataList.get(currentIndex).getTotalHoursOfWork()))) {
                            attendanceDataList.get(currentIndex).setOvertimeWork(overtime);
                            break;
                        } else {
                            overtime = DateUtils.timeSubtraction(overtime, attendanceDataList.get(currentIndex).getTotalHoursOfWork());
                            attendanceDataList.get(recurringDateIndexList.get(j)).setOvertimeWork(attendanceDataList.get(currentIndex).getTotalHoursOfWork());
                        }
                    }
                }
            }
            counter = 0;
            totalHoursOfWorkForRecurringDate = blankTimeHolder;
            overtime = blankTimeHolder;
            recurringDateIndexList.clear();
        }

        for (AttendanceData attendanceData : attendanceDataList) {

            String currentDay = attendanceData.getDay();

            String workHoursForGivenDay = Employee.getWorkHoursForGivenDayStr(employee, currentDay);

            if (checkForNegativeTime(DateUtils.timeSubtraction(workHoursForGivenDay, attendanceData.getTotalHoursOfWork())) && attendanceData.getOvertimeWork() == null) {
                attendanceData.setOvertimeWork(DateUtils.timeSubtraction(attendanceData.getTotalHoursOfWork(), workHoursForGivenDay));
            }
        }

        return attendanceDataList;
    }

    private static boolean isNightWork(Employee employee, String time) {

        return (time.compareTo(employee.getNightWorkStart()) >= 0 && time.compareTo("24:00") <= 0) ||
                (time.compareTo(employee.getNightWorkEnd()) <= 0 && time.compareTo("00:00") >= 0);
    }

    private static boolean isHoliday(List<Holiday> holidayList, Date date) {

        boolean isHoliday = false;

        for (Holiday holiday : holidayList) {
            if (Objects.equals(holiday.getDateOfHoliday(), date)) {
                isHoliday = true;
                break;
            }
        }

        return isHoliday;
    }

    private static boolean checkForNegativeTime(String time) {

        boolean isNegative = false;

        for (char c : time.toCharArray()) {
            if (Objects.equals(c, '-')) {
                isNegative = true;
                break;
            }
        }

        return isNegative;
    }

    private static List<AttendanceData> displayTotalHoursOfWork(List<AttendanceData> attendanceDataList) {

        String totalHoursOfWork = "00:00";
        String totalHoursOfNightWork = "00:00";
        String totalHoursOfSundayWork = "00:00";
        String totalHoursOfHolidayWork = "00:00";
        String totalHoursOfOvertimeWork = "00:00";
        String totalHoursOfOffDaysAndHolidays = "00:00";
        String totalHoursOfAnnualLeave = "00:00";
        String totalHoursOfSickLeave = "00:00";
        String totalHoursOfPaidLeave = "00:00";
        String totalHoursOfUnpaidLeave = "00:00";
        String totalHoursOfExcusedAbsence = "00:00";
        String totalHoursOfUnexcusedAbsence = "00:00";

        for (AttendanceData attendanceData : attendanceDataList) {
            if (!Objects.equals(attendanceData.getTotalHoursOfWork(), null) && !attendanceData.getTotalHoursOfWork().trim().isEmpty()) {
                totalHoursOfWork = DateUtils.timeAddition(totalHoursOfWork, attendanceData.getTotalHoursOfWork());
            }
            if (!Objects.equals(attendanceData.getNightWork(), null) && !attendanceData.getNightWork().trim().isEmpty()) {
                totalHoursOfNightWork = DateUtils.timeAddition(totalHoursOfNightWork, attendanceData.getNightWork());
            }
            if (!Objects.equals(attendanceData.getSundayWork(), null) && !attendanceData.getSundayWork().trim().isEmpty()) {
                totalHoursOfSundayWork = DateUtils.timeAddition(totalHoursOfSundayWork, attendanceData.getSundayWork());
            }
            if (!Objects.equals(attendanceData.getHolidayWork(), null) && !attendanceData.getHolidayWork().trim().isEmpty()) {
                totalHoursOfHolidayWork = DateUtils.timeAddition(totalHoursOfHolidayWork, attendanceData.getHolidayWork());
            }
            if (!Objects.equals(attendanceData.getOvertimeWork(), null) && !attendanceData.getOvertimeWork().trim().isEmpty()) {
                totalHoursOfOvertimeWork = DateUtils.timeAddition(totalHoursOfOvertimeWork, attendanceData.getOvertimeWork());
            }
            if (!Objects.equals(attendanceData.getOffDaysAndHolidays(), null) && !attendanceData.getOffDaysAndHolidays().trim().isEmpty()) {
                totalHoursOfOffDaysAndHolidays = DateUtils.timeAddition(totalHoursOfOffDaysAndHolidays, attendanceData.getOffDaysAndHolidays());
            }
            if (!Objects.equals(attendanceData.getAnnualLeave(), null) && !attendanceData.getAnnualLeave().trim().isEmpty()) {
                totalHoursOfAnnualLeave = DateUtils.timeAddition(totalHoursOfAnnualLeave, attendanceData.getAnnualLeave());
            }
            if (!Objects.equals(attendanceData.getSickLeave(), null) && !attendanceData.getSickLeave().trim().isEmpty()) {
                totalHoursOfSickLeave = DateUtils.timeAddition(totalHoursOfSickLeave, attendanceData.getSickLeave());
            }
            if (!Objects.equals(attendanceData.getPaidLeave(), null) && !attendanceData.getPaidLeave().trim().isEmpty()) {
                totalHoursOfPaidLeave = DateUtils.timeAddition(totalHoursOfPaidLeave, attendanceData.getPaidLeave());
            }
            if (!Objects.equals(attendanceData.getUnpaidLeave(), null) && !attendanceData.getUnpaidLeave().trim().isEmpty()) {
                totalHoursOfUnpaidLeave = DateUtils.timeAddition(totalHoursOfUnpaidLeave, attendanceData.getUnpaidLeave());
            }
            if (!Objects.equals(attendanceData.getExcusedAbsence(), null) && !attendanceData.getExcusedAbsence().trim().isEmpty()) {
                totalHoursOfExcusedAbsence = DateUtils.timeAddition(totalHoursOfExcusedAbsence, attendanceData.getExcusedAbsence());
            }
            if (!Objects.equals(attendanceData.getUnexcusedAbsence(), null) && !attendanceData.getUnexcusedAbsence().trim().isEmpty()) {
                totalHoursOfUnexcusedAbsence = DateUtils.timeAddition(totalHoursOfUnexcusedAbsence, attendanceData.getUnexcusedAbsence());
            }
        }

        attendanceDataList.add(new AttendanceData(
                                totalHoursOfWork,
                                totalHoursOfNightWork,
                                totalHoursOfSundayWork,
                                totalHoursOfHolidayWork,
                                totalHoursOfOvertimeWork,
                                totalHoursOfOffDaysAndHolidays,
                                totalHoursOfAnnualLeave,
                                totalHoursOfSickLeave,
                                totalHoursOfPaidLeave,
                                totalHoursOfUnpaidLeave,
                                totalHoursOfExcusedAbsence,
                                totalHoursOfUnexcusedAbsence));

        return attendanceDataList;
    }
}